#!/usr/bin/env python
# -*- coding: utf-8 -*-

# -------------------------------------------------------------------
# This file is part of the extensive automation project
# Copyright (c) 2010-2018 Denis Machard
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301 USA
#
# Author: Denis Machard
# Contact: d.machard@gmail.com
# Website: www.extensiveautomation.org
# -------------------------------------------------------------------

try:
    from PyQt4.QtGui import (QWidget, QApplication, QPlainTextEdit, QPushButton, QHBoxLayout, QVBoxLayout,
                                QMessageBox, QFileDialog, QAbstractItemView, QTableView, QTabWidget, QLabel,
                                QProgressBar, QCheckBox, QGridLayout)
    from PyQt4.QtCore import ( Qt, QObject, pyqtSignal, QAbstractTableModel, QModelIndex)         
except ImportError:
    from PyQt5.QtWidgets import (QApplication, QWidget, QPlainTextEdit, QPushButton, QHBoxLayout, QVBoxLayout,
                                 QMessageBox, QFileDialog, QAbstractItemView, QTableView, QTabWidget, QLabel,
                                 QProgressBar, QCheckBox, QGridLayout)
    from PyQt5.QtCore import ( Qt, QObject, pyqtSignal, QAbstractTableModel, QModelIndex)    

from Libs import QtHelper, Logger

import xml.etree.ElementTree as ET
import csv
import copy

# design use on debug mode only       
DESIGN_EXAMPLE="""<?xml version="1.0" encoding="UTF-8"?>
<designs max="3">
	<design id="1">
		<user>admin</user>
		<fileproject>Common</fileproject>
		<filepath>/Bugs/</filepath>
		<filename>test_amp</filename>
		<testproject>Common</testproject>
		<testpath>/Bugs</testpath>
		<testname>Noname2 &amp; Test</testname>
		<testcase>TESTCASE</testcase>
		<requirement />
		<purpose><![CDATA[Testcase generated by test assistant]]></purpose>
		<steps>
			<step id="1">
				<summary><![CDATA[]]>dsq</summary>
				<action><![CDATA[]]>dsq</action>
				<expected><![CDATA[Action executed with success]]></expected>
			</step>
		</steps>
	</design>
	<design id="2">
		<user>admin</user>
		<fileproject>Common</fileproject>
		<filepath>/Bugs/</filepath>
		<filename>test_amp</filename>
		<testproject>Common</testproject>
		<testpath>/Basics/Do</testpath>
		<testname>01_Wait</testname>
		<testcase>TESTCASE</testcase>
		<requirement />
		<purpose><![CDATA[Testcase do nothing]]></purpose>
		<steps>
			<step id="1">
				<summary><![CDATA[Do nothing until the end of the timeout]]></summary>
				<action><![CDATA[Do nothing until the end of the timeout]]></action>
				<expected><![CDATA[Action executed with success]]></expected>
			</step>
			<step id="2">
				<summary><![CDATA[hello]]></summary>
				<action><![CDATA[world]]></action>
				<expected><![CDATA[world]]></expected>
			</step>
		</steps>
	</design>
	<design id="3">
		<user>admin</user>
		<fileproject>Common</fileproject>
		<filepath>/Bugs/</filepath>
		<filename>test_amp</filename>
		<testproject>Common</testproject>
		<testpath>/Bugs</testpath>
		<testname>helo</testname>
		<testcase>TESTCASE_01</testcase>
		<requirement><![CDATA[REQ_01]]></requirement>
		<purpose><![CDATA[Testcase sample]]></purpose>
		<steps>
			<step id="1">
				<summary><![CDATA[step sample]]></summary>
				<action><![CDATA[step description]]></action>
				<expected><![CDATA[result expected]]></expected>
			</step>
			<step id="2">
				<summary><![CDATA[hello2]]></summary>
				<action><![CDATA[world2]]></action>
				<expected><![CDATA[world2]]></expected>
			</step>
			<step id="2">
				<summary><![CDATA[hello3]]></summary>
				<action><![CDATA[world3]]></action>
				<expected><![CDATA[world3]]></expected>
			</step>
		</steps>
	</design>
</designs>"""
 
 

CFG_COL_KEY      =   0
CFG_COL_VALUE     =   1

CFG_HEADERS             = ( 'Key', 'Value' )
 
class ConfigsTableModel(QAbstractTableModel):
    """
    Table model for parameters
    """
    def __init__(self, parent, core):
        """
        Table Model for parameters

        @param parent: 
        @type parent:
        """
        QAbstractTableModel.__init__(self, parent)
        
        self.mydata = []
        self.owner = parent
        self.__core = core
        self.nbCol = len(CFG_HEADERS)

    def core(self):
        """
        """
        return self.__core
        
    def getData(self):
        """
        Return model data

        @return:
        @rtype:
        """
        return self.mydata

    def getValueRow(self, index):
        """
        Return all current values of the row

        @param index: 
        @type index:

        @return:
        @rtype:
        """
        return self.mydata[ index.row() ]

    def setDataModel(self, data):
        """
        Set model data

        @param data: 
        @type data:
        """
        self.mydata = data
        self.beginResetModel()
        self.endResetModel()

    def columnCount(self, qindex=QModelIndex()):
        """
        Array column number
    
        @param qindex: 
        @type qindex:

        @return:
        @rtype:
        """
        return self.nbCol

    def rowCount(self, qindex=QModelIndex()):
        """
        Array row number
    
        @param qindex: 
        @type qindex:
    
        @return:
        @rtype:
        """
        return len( self.mydata )
  
    def getValue(self, index):
        """
        Return current value

        @param index: 
        @type index:

        @return:
        @rtype:
        """
        if index.column() == CFG_COL_KEY:
            return self.mydata[ index.row() ]['key']
        elif index.column() == CFG_COL_VALUE:
            return self.mydata[ index.row() ]['value']
        else:
            pass
        
    def data(self, index, role=Qt.DisplayRole):
        """
        Cell content

        @param index: 
        @type index:

        @param role: 
        @type role:

        @return:
        @rtype:
        """
        if not index.isValid(): return None
        value = self.getValue(index)
        
        if role == Qt.DisplayRole:
            return value
        elif role == Qt.EditRole:
            return value
            
    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """
        Overriding method headerData

        @param section: 
        @type section:

        @param orientation: 
        @type orientation:

        @param role: 
        @type role:

        @return:
        @rtype:
        """
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return CFG_HEADERS[section]

        return None

    def setValue(self, index, value):
        """
        Set value

        @param index: 
        @type index:

        @param value: 
        @type value:
        """
        if index.column() == CFG_COL_VALUE:
            self.mydata[ index.row() ]['value'] = value

    def setData(self, index, value, role=Qt.EditRole):
        """
        Cell content change

        @param index: 
        @type index:

        @param value: 
        @type value:

        @param role: 
        @type role:

        @return:
        @rtype:
        """
        if not index.isValid(): return False
        value = QtHelper.displayToValue( value )
        self.setValue(index, value)
        return True

    def flags(self, index):
        """
        Overriding method flags

        @param index: 
        @type index:

        @return:
        @rtype:
        """
        if not index.isValid():
            return Qt.ItemIsEnabled
        if index.column() == CFG_COL_KEY:
            return Qt.ItemFlags(QAbstractTableModel.flags(self, index))
        else:
            return Qt.ItemFlags(QAbstractTableModel.flags(self, index)| Qt.ItemIsEditable| Qt.ItemIsDragEnabled)
     
class ConfigsTableView(QTableView):
    def __init__(self, parent, core):
        """
        """
        QTableView.__init__(self, parent)
        self.__core = core
        
        self.createWidgets()
        self.createConnections()
    
    def core(self):
        """
        """
        return self.__core
        
    def createConnections(self):
        """
        """
        self.clicked.connect( self.onAbstractItemClicked) 
        
    def createWidgets(self):
        """
        """
        self.model = ConfigsTableModel(self, core=self.core())
        self.setModel(self.model)
        
        self.setShowGrid(True)
        self.setGridStyle (Qt.DotLine)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        
        self.verticalHeader().setVisible(False)
        self.horizontalHeader().setHighlightSections(False)
        self.horizontalHeader().setStretchLastSection(True)

    def onAbstractItemClicked(self):
        """
        """
        indexes = self.selectedIndexes()
        if not indexes:
            return

    def adjustRows (self):
        """
        Resize row to contents
        """
        data = self.model.getData()
        for row in range(len(data)):
            self.resizeRowToContents(row)
    
    def adjustColumns(self):
        """
        Resize two first columns to contents
        """
        for col in [CFG_COL_KEY, CFG_COL_VALUE]:
            self.resizeColumnToContents(col)

    def clear(self):
        """
        Clear all widget
        """
        self.model.setDataModel( [] )
        
    def loadTable (self, data):
        """
        Load data

        @param data: 
        @type data:
        """
        self.model.setDataModel( data )
        
        self.adjustRows()
        self.adjustColumns()
   
STEPS_COL_ID      =   0
STEPS_COL_SUMMARY     =   1
STEPS_COL_ACTION    =   2
STEPS_COL_EXPECTED    =   3

STEPS_HEADERS             = ( 'Id', 'Summary', 'Action', 'Expected' )
 
class StepsTableModel(QAbstractTableModel):
    """
    Table model for parameters
    """
    def __init__(self, parent, core):
        """
        Table Model for parameters

        @param parent: 
        @type parent:
        """
        QAbstractTableModel.__init__(self, parent)
        
        self.mydata = []
        self.owner = parent
        self.__core = core
        self.nbCol = len(STEPS_HEADERS)

    def core(self):
        """
        """
        return self.__core
        
    def getData(self):
        """
        Return model data

        @return:
        @rtype:
        """
        return self.mydata

    def getValueRow(self, index):
        """
        Return all current values of the row

        @param index: 
        @type index:

        @return:
        @rtype:
        """
        return self.mydata[ index.row() ]

    def setDataModel(self, data):
        """
        Set model data

        @param data: 
        @type data:
        """
        self.mydata = data
        self.beginResetModel()
        self.endResetModel()

    def columnCount(self, qindex=QModelIndex()):
        """
        Array column number
    
        @param qindex: 
        @type qindex:

        @return:
        @rtype:
        """
        return self.nbCol

    def rowCount(self, qindex=QModelIndex()):
        """
        Array row number
    
        @param qindex: 
        @type qindex:
    
        @return:
        @rtype:
        """
        return len( self.mydata )
  
    def getValue(self, index):
        """
        Return current value

        @param index: 
        @type index:

        @return:
        @rtype:
        """
        if index.column() == STEPS_COL_ID:
            return index.row() + 1
        elif index.column() == STEPS_COL_SUMMARY:
            return self.mydata[ index.row() ]['summary']
        elif index.column() == STEPS_COL_ACTION:
            return self.mydata[ index.row() ]['action']
        elif index.column() == STEPS_COL_EXPECTED:
            return self.mydata[ index.row() ]['expected']
        else:
            pass
        
    def data(self, index, role=Qt.DisplayRole):
        """
        Cell content

        @param index: 
        @type index:

        @param role: 
        @type role:

        @return:
        @rtype:
        """
        if not index.isValid(): return None
        value = self.getValue(index)
        
        if role == Qt.DisplayRole:
            return value
        elif role == Qt.EditRole:
            return value
            
    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """
        Overriding method headerData

        @param section: 
        @type section:

        @param orientation: 
        @type orientation:

        @param role: 
        @type role:

        @return:
        @rtype:
        """
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return STEPS_HEADERS[section]

        return None

    def setValue(self, index, value):
        """
        Set value

        @param index: 
        @type index:

        @param value: 
        @type value:
        """
        if index.column() == STEPS_COL_SUMMARY:
            self.mydata[ index.row() ]['summary'] = value
        elif index.column() == STEPS_COL_ACTION:
            self.mydata[ index.row() ]['action'] = value
        elif index.column() == STEPS_COL_EXPECTED:
            self.mydata[ index.row() ]['expected'] = value
    
    def setData(self, index, value, role=Qt.EditRole):
        """
        Cell content change

        @param index: 
        @type index:

        @param value: 
        @type value:

        @param role: 
        @type role:

        @return:
        @rtype:
        """
        if not index.isValid(): return False
        value = QtHelper.displayToValue( value )
        self.setValue(index, value)
        return True

    def flags(self, index):
        """
        Overriding method flags

        @param index: 
        @type index:

        @return:
        @rtype:
        """
        if not index.isValid():
            return Qt.ItemIsEnabled
        if index.column() == COL_ID:
            return Qt.ItemFlags(QAbstractTableModel.flags(self, index))
        else:
            return Qt.ItemFlags(QAbstractTableModel.flags(self, index)| Qt.ItemIsEditable| Qt.ItemIsDragEnabled)
     
class StepsTableView(QTableView):
    def __init__(self, parent, core):
        """
        """
        QTableView.__init__(self, parent)
        self.__core = core
        
        self.createWidgets()
        self.createConnections()
    
    def core(self):
        """
        """
        return self.__core
        
    def createConnections(self):
        """
        """
        self.clicked.connect( self.onAbstractItemClicked) 
        
    def createWidgets(self):
        """
        """
        self.model = StepsTableModel(self, core=self.core())
        self.setModel(self.model)
        
        self.setShowGrid(True)
        self.setGridStyle (Qt.DotLine)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        
        self.verticalHeader().setVisible(False)
        self.horizontalHeader().setHighlightSections(False)
        self.horizontalHeader().setStretchLastSection(True)

    def onAbstractItemClicked(self):
        """
        """
        indexes = self.selectedIndexes()
        if not indexes:
            return

    def adjustRows (self):
        """
        Resize row to contents
        """
        data = self.model.getData()
        for row in range(len(data)):
            self.resizeRowToContents(row)
    
    def adjustColumns(self):
        """
        Resize two first columns to contents
        """
        for col in [STEPS_COL_ID, STEPS_COL_SUMMARY, STEPS_COL_ACTION, STEPS_COL_EXPECTED]:
            self.resizeColumnToContents(col)

    def clear(self):
        """
        Clear all widget
        """
        self.model.setDataModel( [] )
        
    def loadTable (self, data):
        """
        Load data

        @param data: 
        @type data:
        """
        self.model.setDataModel( data )

        self.adjustColumns()
        self.adjustRows()
        
COL_ID      =   0
COL_PATH    =   1
COL_NAME    =   2
COL_CASE    =   3
COL_REQ     =   4
COL_PURP    =   5


HEADERS             = ( 'Id', 'Path', 'TestName', 'TestCase', 'Requirement', 'Purpose' )
 
class TestsTableModel(QAbstractTableModel):
    """
    Table model for parameters
    """
    def __init__(self, parent, core):
        """
        Table Model for parameters

        @param parent: 
        @type parent:
        """
        QAbstractTableModel.__init__(self, parent)
        
        self.mydata = []
        self.owner = parent
        self.__core = core
        self.nbCol = len(HEADERS)

    def core(self):
        """
        """
        return self.__core
        
    def getData(self):
        """
        Return model data

        @return:
        @rtype:
        """
        return self.mydata

    def getValueRow(self, index):
        """
        Return all current values of the row

        @param index: 
        @type index:

        @return:
        @rtype:
        """
        return self.mydata[ index.row() ]

    def setDataModel(self, data):
        """
        Set model data

        @param data: 
        @type data:
        """
        self.mydata = data
        self.beginResetModel()
        self.endResetModel()

    def columnCount(self, qindex=QModelIndex()):
        """
        Array column number
    
        @param qindex: 
        @type qindex:

        @return:
        @rtype:
        """
        return self.nbCol

    def rowCount(self, qindex=QModelIndex()):
        """
        Array row number
    
        @param qindex: 
        @type qindex:
    
        @return:
        @rtype:
        """
        return len( self.mydata )
  
    def getValue(self, index):
        """
        Return current value

        @param index: 
        @type index:

        @return:
        @rtype:
        """
        if index.column() == COL_ID:
            return index.row() + 1
        elif index.column() == COL_PATH:
            return self.mydata[ index.row() ]['testpath']
        elif index.column() == COL_NAME:
            return self.mydata[ index.row() ]['testname']
        elif index.column() == COL_CASE:
            return self.mydata[ index.row() ]['testcase']
        elif index.column() == COL_PURP:
            return self.mydata[ index.row() ]['purpose']  
        elif index.column() == COL_REQ:
            return self.mydata[ index.row() ]['requirement']  
        else:
            pass
        
    def data(self, index, role=Qt.DisplayRole):
        """
        Cell content

        @param index: 
        @type index:

        @param role: 
        @type role:

        @return:
        @rtype:
        """
        if not index.isValid(): return None
        value = self.getValue(index)
        
        if role == Qt.DisplayRole:
            return value
        elif role == Qt.EditRole:
            return value
            
    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """
        Overriding method headerData

        @param section: 
        @type section:

        @param orientation: 
        @type orientation:

        @param role: 
        @type role:

        @return:
        @rtype:
        """
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return HEADERS[section]

        return None

    def setValue(self, index, value):
        """
        Set value

        @param index: 
        @type index:

        @param value: 
        @type value:
        """
        if index.column() == COL_PATH:
            self.mydata[ index.row() ]['testpath'] = value
        elif index.column() == COL_NAME:
            self.mydata[ index.row() ]['testname'] = value
        elif index.column() == COL_CASE:
            self.mydata[ index.row() ]['testcase'] = value
        elif index.column() == COL_REQ:
            self.mydata[ index.row() ]['requirement'] = value
        elif index.column() == COL_PURP:
            self.mydata[ index.row() ]['purpose'] = value
            
    def setData(self, index, value, role=Qt.EditRole):
        """
        Cell content change

        @param index: 
        @type index:

        @param value: 
        @type value:

        @param role: 
        @type role:

        @return:
        @rtype:
        """
        if not index.isValid(): return False
        value = QtHelper.displayToValue( value )
        self.setValue(index, value)
        return True

    def flags(self, index):
        """
        Overriding method flags

        @param index: 
        @type index:

        @return:
        @rtype:
        """
        if not index.isValid():
            return Qt.ItemIsEnabled
        if index.column() == COL_ID:
            return Qt.ItemFlags(QAbstractTableModel.flags(self, index))
        else:
            return Qt.ItemFlags(QAbstractTableModel.flags(self, index)| Qt.ItemIsEditable| Qt.ItemIsDragEnabled)
     
class TestsTableView(QTableView):
    LoadSteps = pyqtSignal(list) 
    def __init__(self, parent, core):
        """
        """
        QTableView.__init__(self, parent)
        self.__core = core
        
        self.createWidgets()
        self.createConnections()
    
    def core(self):
        """
        """
        return self.__core
        
    def createConnections(self):
        """
        """
        pass

    def selectionChanged(self, selected, deselected):
        """
        selection changed
        """
        QTableView.selectionChanged(self, selected, deselected)

        self.onAbstractItemClicked()
        
    def createWidgets(self):
        """
        """
        self.model = TestsTableModel(self, core=self.core())
        self.setModel(self.model)
        
        self.setShowGrid(True)
        self.setGridStyle(Qt.DotLine)
        
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)
        
        self.verticalHeader().setVisible(False)
        self.horizontalHeader().setHighlightSections(False)
        self.horizontalHeader().setStretchLastSection(True)

    def onAbstractItemClicked(self):
        """
        """
        sourceIndex = self.selectedIndexes()
        if not sourceIndex:
            return
        
        selectedIndex = sourceIndex[0].row()
        row = self.model.getData()[selectedIndex]
        
        self.LoadSteps.emit(row['steps'])
    
    def adjustColumns(self):
        """
        Resize two first columns to contents
        """
        for col in [COL_ID, COL_PATH, COL_NAME, COL_CASE, COL_REQ, COL_PURP  ]:
            self.resizeColumnToContents(col)

    def adjustRows (self):
        """
        Resize row to contents
        """
        data = self.model.getData()
        for row in range(len(data)):
            self.resizeRowToContents(row)

    def clear(self):
        """
        Clear all widget
        """
        self.model.setDataModel( [] )
        
    def loadTable (self, data):
        """
        Load data

        @param data: 
        @type data:
        """
        self.model.setDataModel( data )
        
        self.adjustColumns()
        self.adjustRows()

class DesignPage(QWidget):
    """
    Design Export Page
    """
    ExportTests = pyqtSignal(list, dict) 
    def __init__(self, parent, core, debugMode=False):
        """
        Constructor
        @param parent:
        """
        QWidget.__init__(self, parent)
        self.__core = core
        self.__debugMode = debugMode
        self.__rawXml = ""
        self.__listCsv = []
        
        self.createWidgets()
        self.creationConnections()
        
        if self.__debugMode: self.readXml(rawXml=DESIGN_EXAMPLE)
    
    def core(self):
        """
        """
        return self.__core

    def creationConnections (self):
        """
        QtSignals connection:
        """
        self.exportButton.clicked.connect( self.exportClicked )
        self.loadCsvButton.clicked.connect( self.loadCsv )
        self.testsTable.LoadSteps.connect( self.onLoadSteps )
        
        self.mergeCheckBox.toggled.connect( self.onOptionToggled )
        self.showTcNameCheckBox.toggled.connect( self.onOptionToggled )
        self.mergeStepsCheckBox.toggled.connect( self.onOptionToggled )
        self.replaceTcCheckBox.toggled.connect( self.onOptionToggled )
        
    def createWidgets(self):
        """
        """
        # options
        self.mergeCheckBox = QCheckBox(self.tr("Merge all tests in one"))
        if self.core().settings().cfg()["export-tests"]["merge-all-tests"]:
            self.mergeCheckBox.setCheckState(Qt.Checked) 
            
        self.showTcNameCheckBox = QCheckBox(self.tr("Load with original test name"))
        if self.core().settings().cfg()["export-tests"]["original-test"]:
            self.showTcNameCheckBox.setCheckState(Qt.Checked) 
            
        self.replaceTcCheckBox = QCheckBox(self.tr("Replace testcase with testname"))
        if self.core().settings().cfg()["export-tests"]["replace-testcase"]:
            self.replaceTcCheckBox.setCheckState(Qt.Checked) 
            
        self.mergeStepsCheckBox = QCheckBox(self.tr("Merge all steps in one"))
        if self.core().settings().cfg()["export-tests"]["merge-all-steps"]:
            self.mergeStepsCheckBox.setCheckState(Qt.Checked) 
            
        self.addMissingFoldersCheckBox = QCheckBox(self.tr("Create missing folders"))
        if self.core().settings().cfg()["export-tests"]["add-folders"]:
            self.addMissingFoldersCheckBox.setCheckState(Qt.Checked) 
            
        self.overwriteTcCheckBox = QCheckBox(self.tr("Overwrite testcase(s)"))
        if self.core().settings().cfg()["export-tests"]["overwrite-tests"]:
            self.overwriteTcCheckBox.setCheckState(Qt.Checked) 
            
        # actions to export
        self.loadCsvButton = QPushButton(self.tr("Load CSV"), self)
        
        self.exportButton = QPushButton(self.tr("Export Test"), self)
        self.exportButton.setMinimumWidth(300)
        self.exportStatusLabel = QLabel( "Status: Disconnected", self)

        # tables definition
        self.testsTable = TestsTableView(self, core=self.core())
        self.stepsTable = StepsTableView(self, core=self.core())
        
        # options layout
        optionsTpLayout = QHBoxLayout()
        optionsTpLayout.addWidget(self.addMissingFoldersCheckBox)
        optionsTpLayout.addWidget(self.overwriteTcCheckBox)
        optionsTpLayout.addStretch(1)
        
        optionsLayout = QHBoxLayout()
        optionsLayout.addWidget(self.mergeCheckBox)
        optionsLayout.addWidget(self.showTcNameCheckBox)
        optionsLayout.addWidget(self.replaceTcCheckBox)
        optionsLayout.addStretch(1)
        
        layoutGrid = QGridLayout()
        layoutGrid.addWidget(QLabel("Remote TestPlan:"), 0, 0)
        layoutGrid.addLayout(optionsTpLayout, 0, 1)
        layoutGrid.addWidget(QLabel("Local Test:"), 1, 0)
        layoutGrid.addLayout(optionsLayout, 1, 1)
        layoutGrid.addWidget(QLabel("Tests Listing:"), 2, 0)
        layoutGrid.addWidget(self.testsTable, 2, 1)
        layoutGrid.addWidget(self.mergeStepsCheckBox, 3, 1)
        layoutGrid.addWidget(QLabel("Steps Listing:"), 4, 0)
        layoutGrid.addWidget(self.stepsTable, 4, 1)
        
        layoutRight = QHBoxLayout()
        layoutRight.addWidget(self.exportButton)
        layoutRight.addWidget(self.loadCsvButton)
        layoutRight.addWidget(self.exportStatusLabel)
        layoutRight.addStretch(1)
        
        layoutGrid.addWidget(QLabel("Controls:"), 5, 0)
        layoutGrid.addLayout(layoutRight, 5, 1)
        
        layoutMain = QVBoxLayout()
        layoutMain.addLayout(layoutGrid)
    
        self.setLayout(layoutMain)

    def resetBuffers(self):
        """
        """
        self.__rawXml = ""
        self.__listCsv = []
        
    def loadCsv(self):
        """
        """
        self.resetBuffers()
        
        fileName = QFileDialog.getOpenFileName(self,
              self.tr("Open File"), "", "CSV (*.csv)")
        if not len(fileName):
            return

        csv.register_dialect('coma', delimiter=';')

        tests = []
            
        with open(fileName, encoding='iso-8859-1') as f:
            reader = csv.DictReader(f, dialect="coma")
            prev = None
            for row in reader:
                if prev is not None:
                    if prev["testpath"] == row["testpath"] and prev["testcase"] == row["testcase"]:
                        prev["steps"].append( { 
                                            "summary": row["step description"],
                                            "action": row["step description"],         
                                            "expected": row["step expected"] 
                                        } )
                        continue

                test = {
                            "testpath": row["testpath"], 
                            "requirement": "", 
                            "testname": "",
                            "testcase": row["testcase"], 
                            "purpose": row["purpose"], 
                            "steps": [ 
                                        { 
                                            "summary": row["step description"],
                                            "action": row["step description"],         
                                            "expected": row["step expected"] 
                                        }
                                    ]
                        }
                tests.append(test)
                prev = test

        self.readListCsv(listCsv=tests)
        
    def exportClicked (self):
        """
        Called on accept button
        """
        indexes = self.testsTable.selectionModel().selectedRows()
        if not len(indexes):
            QMessageBox.warning(self, self.tr("Export Test") , 
                                self.tr("Please to select a testcase!") )
            return
        
        testcases = []
        
        error = False
        for index in indexes:
            selectedIndex = index.row()
            row = self.testsTable.model.getData()[selectedIndex]
            if not len(row["testcase"]): error = True
            testcases.append(row)
        
        if error: 
            QMessageBox.warning(self, self.tr("Export Test") , 
                                self.tr("Please to set a testcase name!") )
            return

        config = {}
        for cfg in self.core().settings().cfg()["custom-test-fields"]:
            config.update( {cfg["key"]: cfg["value"] } )
            
        self.disableExport()
        
        config["Add_Folders"] = self.addMissingFoldersCheckBox.isChecked()
        config["Overwrite_Tests"] = self.overwriteTcCheckBox.isChecked()
                    
        self.ExportTests.emit(testcases, config)
        
    def onOptionToggled (self, toggled):
        """
        Called on accept button
        """
        # reload from initial dict
        if len(self.__listCsv):
            self.readListCsv(listCsv=self.__listCsv)
        
        # reload from initial xml, default       
        else:
            self.readXml(rawXml=self.__rawXml)

    def logStatus(self, status):
        """
        """
        self.exportStatusLabel.setText(status)
        
    def enableExport(self):
        """
        """
        self.exportButton.setEnabled(True)
        
    def disableExport(self):
        """
        """
        self.exportButton.setEnabled(False)
 
    def onLoadSteps(self, steps):
        """
        """
        self.stepsTable.loadTable(data=steps)

    def onLoadTests(self, data):
        """
        """
        self.stepsTable.clear()
        self.testsTable.loadTable(data=data)

    def readListCsv(self, listCsv):
        """
        """
        self.resetBuffers()
        
        self.__listCsv = listCsv
        
        testcases = copy.deepcopy(listCsv)

        if self.mergeCheckBox.isChecked(): testcases = self.mergeTests(testcases=testcases)
            
        for tc in testcases:
            # read and merge all tests in one ?
            if self.mergeStepsCheckBox.isChecked(): tc["steps"] = self.mergeCsvSteps(steps=tc["steps"])

        # finally loading all tests in table model
        self.core().debug().addLogSuccess("Tests detected in csv: %s"  % len(testcases) )
        if len(testcases):  self.onLoadTests(data=testcases)
        
    def mergeTests(self, testcases):
        """
        """
        tc = {
                    "testpath": testcases[0]["testpath"], 
                    "requirement": testcases[0]["requirement"], 
                    "testname": testcases[0]["testname"], 
                    "testcase": testcases[0]["testcase"], 
                    "purpose": testcases[0]["purpose"],  
                    "steps": []
                }
        for t in testcases:  tc["steps"].extend(t["steps"]) 
        return [ tc ]
        
    def mergeCsvSteps(self, steps):
        """
        """
        summaries = []
        actions = []
        expecteds = []
        i = 0
        for stp in steps:
            i += 1
            summaries.append( "%s. %s" %  (i, stp["summary"]) )
            actions.append( "%s. %s" %  (i, stp["action"]) )
            expecteds.append( "%s. %s" % (i, stp["expected"]) )
            
        ret = {
                 'summary': "\n".join(summaries),
                 'action': "\n".join(actions),
                 'expected': "\n".join(expecteds)
                }
        return [ ret ]
        
    def readXml(self, rawXml):
        """
        """
        self.resetBuffers()
        
        # init and save the xml provided
        self.__rawXml = rawXml
        testcases = []
        
        # load the xml provided
        try:
            root = ET.fromstring(rawXml)
        except Exception as e:
            self.core().debug().addLogError("Unable to read xml: %s"  % e )
        else: 
            designs = root.find(".")

            # read and merge all tests in one ?
            if self.mergeCheckBox.isChecked(): testcases = self.mergeXmlTests(designsXml=designs)
                
            # otherwise read all tests
            else: testcases = self.readXmlTests(designsXml=designs)
             
            # finally loading all tests in table model
            self.core().debug().addLogSuccess("Export tests detected: %s"  % len(testcases) )
            if len(testcases):  self.onLoadTests(data=testcases)

    def mergeXmlTests(self, designsXml):
        """
        """
        testcases = []
        tc = { "steps": [] }
        summaries = []
        actions = []
        expecteds = []
        delta = 0
        for i in range(len(designsXml)):
            if i == 0:
                tc["requirement"] = designsXml[i].find("requirement").text
                tc["purpose"] = designsXml[i].find("purpose").text
                if self.showTcNameCheckBox.isChecked():
                    tc["testpath"] = designsXml[i].find("testpath").text
                    tc["testname"] = designsXml[i].find("testname").text
                    tc["testcase"] = designsXml[i].find("testcase").text
                else:
                    tc["testpath"] = designsXml[i].find("filepath").text
                    tc["testname"] = designsXml[i].find("filename").text
                    tc["testcase"] = designsXml[i].find("testname").text
                    
                if self.replaceTcCheckBox.isChecked():
                    tc["testpath"] = designsXml[i].find("filepath").text
                    tc["testname"] = ""
                    tc["testcase"] = designsXml[i].find("filename").text
                    
            stepsDesigns = designsXml[i].findall("steps/step")

            steps, nb_steps = self.readXmlSteps(stepsXml=stepsDesigns, delta=delta)
            delta += nb_steps
            if self.mergeStepsCheckBox.isChecked() and len(steps):
                summaries.append(steps[0]["summary"])
                actions.append(steps[0]["action"])
                expecteds.append(steps[0]["expected"])
            else:
                tc["steps"].extend(steps) 

        testcases.append(tc)
        if self.mergeStepsCheckBox.isChecked():
            stp = {
                     'summary': "\n".join(summaries),
                     'action': "\n".join(actions),
                     'expected': "\n".join(expecteds)
                    }
            tc["steps"].extend( [ stp ] )
        return testcases
        
    def readXmlTests(self, designsXml):
        """
        """
        testcases = []
        for design in designsXml:
            tc = { 
                    "requirement": design.find("requirement").text,
                    "purpose": design.find("purpose").text,
                 }
            
            # replace testcase name ?
            if not self.showTcNameCheckBox.isChecked():
                tc.update( {
                            "testpath": design.find("filepath").text,
                            "testname": design.find("filename").text,
                            "testcase": design.find("testname").text
                            } )
            else:
                tc.update( {
                            "testpath": design.find("testpath").text,
                            "testname": design.find("testname").text,
                            "testcase": design.find("testcase").text
                            } )
                            
            if self.replaceTcCheckBox.isChecked():
                tc.update( {
                            "testpath": design.find("testpath").text,
                            "testname": "",
                            "testcase": design.find("testname").text
                            } )
                
            # read steps
            stepsDesigns = design.findall("steps/step")
            steps, nb_steps = self.readXmlSteps(stepsXml=stepsDesigns)
            tc.update( {"steps": steps} )
            
            testcases.append(tc)
        return testcases
        
    def readXmlSteps(self, stepsXml, delta=0):
        """
        """
        steps = []
        summaries = []
        actions = []
        expecteds = []
        i = 0
        for stp in stepsXml:
            i += 1
            summary = stp.find("summary").text
            action = stp.find("action").text
            expected = stp.find("expected").text
            if self.mergeStepsCheckBox.isChecked():
                summaries.append( "%s. %s" % (i + delta, summary) )
                actions.append( "%s. %s" % (i + delta, action) )
                expecteds.append( "%s. %s" % (i + delta, expected) )
            else:
                stp = {
                         'summary': summary,
                         'action': action,
                         'expected': expected
                        }
                steps.append(stp)
                
        if self.mergeStepsCheckBox.isChecked():
            stp = {
                     'summary': "\n".join(summaries),
                     'action': "\n".join(actions),
                     'expected': "\n".join(expecteds)
                    }
            steps.append(stp)
        return (steps, i)